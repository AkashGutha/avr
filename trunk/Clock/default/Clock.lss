
Clock.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001c  00800100  00000a46  00000ada  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000a46  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000e  0080011c  0080011c  00000af6  2**0
                  ALLOC
  3 .debug_aranges 00000040  00000000  00000000  00000af6  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000001d1  00000000  00000000  00000b36  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000752  00000000  00000000  00000d07  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000002b2  00000000  00000000  00001459  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000090b  00000000  00000000  0000170b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000180  00000000  00000000  00002018  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000236  00000000  00000000  00002198  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000023d  00000000  00000000  000023ce  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	2b c0       	rjmp	.+86     	; 0x58 <__ctors_end>
   2:	45 c0       	rjmp	.+138    	; 0x8e <__bad_interrupt>
   4:	44 c0       	rjmp	.+136    	; 0x8e <__bad_interrupt>
   6:	7b c2       	rjmp	.+1270   	; 0x4fe <__vector_3>
   8:	42 c0       	rjmp	.+132    	; 0x8e <__bad_interrupt>
   a:	41 c0       	rjmp	.+130    	; 0x8e <__bad_interrupt>
   c:	40 c0       	rjmp	.+128    	; 0x8e <__bad_interrupt>
   e:	3f c0       	rjmp	.+126    	; 0x8e <__bad_interrupt>
  10:	3e c0       	rjmp	.+124    	; 0x8e <__bad_interrupt>
  12:	3d c0       	rjmp	.+122    	; 0x8e <__bad_interrupt>
  14:	3c c0       	rjmp	.+120    	; 0x8e <__bad_interrupt>
  16:	52 c1       	rjmp	.+676    	; 0x2bc <__vector_11>
  18:	3a c0       	rjmp	.+116    	; 0x8e <__bad_interrupt>
  1a:	39 c0       	rjmp	.+114    	; 0x8e <__bad_interrupt>
  1c:	38 c0       	rjmp	.+112    	; 0x8e <__bad_interrupt>
  1e:	37 c0       	rjmp	.+110    	; 0x8e <__bad_interrupt>
  20:	36 c0       	rjmp	.+108    	; 0x8e <__bad_interrupt>
  22:	35 c0       	rjmp	.+106    	; 0x8e <__bad_interrupt>
  24:	34 c0       	rjmp	.+104    	; 0x8e <__bad_interrupt>
  26:	33 c0       	rjmp	.+102    	; 0x8e <__bad_interrupt>
  28:	32 c0       	rjmp	.+100    	; 0x8e <__bad_interrupt>
  2a:	31 c0       	rjmp	.+98     	; 0x8e <__bad_interrupt>
  2c:	30 c0       	rjmp	.+96     	; 0x8e <__bad_interrupt>
  2e:	2f c0       	rjmp	.+94     	; 0x8e <__bad_interrupt>
  30:	2e c0       	rjmp	.+92     	; 0x8e <__bad_interrupt>
  32:	2d c0       	rjmp	.+90     	; 0x8e <__bad_interrupt>
  34:	a9 c1       	rjmp	.+850    	; 0x388 <__vector_11+0xcc>
  36:	b4 c1       	rjmp	.+872    	; 0x3a0 <__vector_11+0xe4>
  38:	a7 c1       	rjmp	.+846    	; 0x388 <__vector_11+0xcc>
  3a:	ac c1       	rjmp	.+856    	; 0x394 <__vector_11+0xd8>
  3c:	a5 c1       	rjmp	.+842    	; 0x388 <__vector_11+0xcc>
  3e:	aa c1       	rjmp	.+852    	; 0x394 <__vector_11+0xd8>
  40:	a3 c1       	rjmp	.+838    	; 0x388 <__vector_11+0xcc>
  42:	a2 c1       	rjmp	.+836    	; 0x388 <__vector_11+0xcc>
  44:	a7 c1       	rjmp	.+846    	; 0x394 <__vector_11+0xd8>
  46:	ac c1       	rjmp	.+856    	; 0x3a0 <__vector_11+0xe4>
  48:	ab c1       	rjmp	.+854    	; 0x3a0 <__vector_11+0xe4>
  4a:	aa c1       	rjmp	.+852    	; 0x3a0 <__vector_11+0xe4>
  4c:	a9 c1       	rjmp	.+850    	; 0x3a0 <__vector_11+0xe4>
  4e:	a8 c1       	rjmp	.+848    	; 0x3a0 <__vector_11+0xe4>
  50:	a7 c1       	rjmp	.+846    	; 0x3a0 <__vector_11+0xe4>
  52:	9a c1       	rjmp	.+820    	; 0x388 <__vector_11+0xcc>
  54:	9f c1       	rjmp	.+830    	; 0x394 <__vector_11+0xd8>
  56:	98 c1       	rjmp	.+816    	; 0x388 <__vector_11+0xcc>

00000058 <__ctors_end>:
  58:	11 24       	eor	r1, r1
  5a:	1f be       	out	0x3f, r1	; 63
  5c:	cf ef       	ldi	r28, 0xFF	; 255
  5e:	d4 e0       	ldi	r29, 0x04	; 4
  60:	de bf       	out	0x3e, r29	; 62
  62:	cd bf       	out	0x3d, r28	; 61

00000064 <__do_copy_data>:
  64:	11 e0       	ldi	r17, 0x01	; 1
  66:	a0 e0       	ldi	r26, 0x00	; 0
  68:	b1 e0       	ldi	r27, 0x01	; 1
  6a:	e6 e4       	ldi	r30, 0x46	; 70
  6c:	fa e0       	ldi	r31, 0x0A	; 10
  6e:	02 c0       	rjmp	.+4      	; 0x74 <.do_copy_data_start>

00000070 <.do_copy_data_loop>:
  70:	05 90       	lpm	r0, Z+
  72:	0d 92       	st	X+, r0

00000074 <.do_copy_data_start>:
  74:	ac 31       	cpi	r26, 0x1C	; 28
  76:	b1 07       	cpc	r27, r17
  78:	d9 f7       	brne	.-10     	; 0x70 <.do_copy_data_loop>

0000007a <__do_clear_bss>:
  7a:	11 e0       	ldi	r17, 0x01	; 1
  7c:	ac e1       	ldi	r26, 0x1C	; 28
  7e:	b1 e0       	ldi	r27, 0x01	; 1
  80:	01 c0       	rjmp	.+2      	; 0x84 <.do_clear_bss_start>

00000082 <.do_clear_bss_loop>:
  82:	1d 92       	st	X+, r1

00000084 <.do_clear_bss_start>:
  84:	aa 32       	cpi	r26, 0x2A	; 42
  86:	b1 07       	cpc	r27, r17
  88:	e1 f7       	brne	.-8      	; 0x82 <.do_clear_bss_loop>
  8a:	ee d2       	rcall	.+1500   	; 0x668 <main>
  8c:	da c4       	rjmp	.+2484   	; 0xa42 <_exit>

0000008e <__bad_interrupt>:
  8e:	b8 cf       	rjmp	.-144    	; 0x0 <__vectors>

00000090 <send>:
#include <avr\interrupt.h>
#include <util/delay.h>
#include "ds1307.h"

void send(unsigned char digit, unsigned char data)
{
  90:	58 2f       	mov	r21, r24
  if( digit < 4 )
  92:	84 30       	cpi	r24, 0x04	; 4
  94:	28 f5       	brcc	.+74     	; 0xe0 <send+0x50>
  {
    cli();
  96:	f8 94       	cli
    // Close mux & data lines :
    PORTC = 0x30;
  98:	e8 e2       	ldi	r30, 0x28	; 40
  9a:	f0 e0       	ldi	r31, 0x00	; 0
  9c:	40 e3       	ldi	r20, 0x30	; 48
  9e:	40 83       	st	Z, r20
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
  a0:	22 ee       	ldi	r18, 0xE2	; 226
  a2:	34 e0       	ldi	r19, 0x04	; 4
  a4:	c9 01       	movw	r24, r18
  a6:	01 97       	sbiw	r24, 0x01	; 1
  a8:	f1 f7       	brne	.-4      	; 0xa6 <send+0x16>
    _delay_ms(5);
    PORTD = data;
  aa:	ab e2       	ldi	r26, 0x2B	; 43
  ac:	b0 e0       	ldi	r27, 0x00	; 0
  ae:	6c 93       	st	X, r22
  b0:	c9 01       	movw	r24, r18
  b2:	01 97       	sbiw	r24, 0x01	; 1
  b4:	f1 f7       	brne	.-4      	; 0xb2 <send+0x22>
    _delay_ms(5);
    // Open WE on the selected buffer :
    PORTC = 0x30 | (1 << digit);
  b6:	81 e0       	ldi	r24, 0x01	; 1
  b8:	90 e0       	ldi	r25, 0x00	; 0
  ba:	02 c0       	rjmp	.+4      	; 0xc0 <send+0x30>
  bc:	88 0f       	add	r24, r24
  be:	99 1f       	adc	r25, r25
  c0:	5a 95       	dec	r21
  c2:	e2 f7       	brpl	.-8      	; 0xbc <send+0x2c>
  c4:	80 63       	ori	r24, 0x30	; 48
  c6:	80 83       	st	Z, r24
  c8:	c9 01       	movw	r24, r18
  ca:	01 97       	sbiw	r24, 0x01	; 1
  cc:	f1 f7       	brne	.-4      	; 0xca <send+0x3a>
    _delay_ms(5);
    // Close the mux & data lines :
    PORTC = 0x30;
  ce:	40 83       	st	Z, r20
  d0:	c9 01       	movw	r24, r18
  d2:	01 97       	sbiw	r24, 0x01	; 1
  d4:	f1 f7       	brne	.-4      	; 0xd2 <send+0x42>
    _delay_ms(5);
    PORTD = 0;
  d6:	1c 92       	st	X, r1
  d8:	c9 01       	movw	r24, r18
  da:	01 97       	sbiw	r24, 0x01	; 1
  dc:	f1 f7       	brne	.-4      	; 0xda <send+0x4a>
    _delay_ms(5);
    sei();
  de:	78 94       	sei
  e0:	08 95       	ret

000000e2 <refresh_display>:
unsigned char DST = 1;

unsigned char disp = DISP_TIME;

void refresh_display()
{
  e2:	ef 92       	push	r14
  e4:	ff 92       	push	r15
  e6:	0f 93       	push	r16
  e8:	1f 93       	push	r17
  switch( disp )
  ea:	80 91 28 01 	lds	r24, 0x0128
  ee:	81 30       	cpi	r24, 0x01	; 1
  f0:	c9 f1       	breq	.+114    	; 0x164 <refresh_display+0x82>
  f2:	81 30       	cpi	r24, 0x01	; 1
  f4:	38 f0       	brcs	.+14     	; 0x104 <refresh_display+0x22>
  f6:	82 30       	cpi	r24, 0x02	; 2
  f8:	09 f4       	brne	.+2      	; 0xfc <refresh_display+0x1a>
  fa:	64 c0       	rjmp	.+200    	; 0x1c4 <refresh_display+0xe2>
  fc:	83 30       	cpi	r24, 0x03	; 3
  fe:	09 f0       	breq	.+2      	; 0x102 <refresh_display+0x20>
 100:	a6 c0       	rjmp	.+332    	; 0x24e <refresh_display+0x16c>
 102:	86 c0       	rjmp	.+268    	; 0x210 <refresh_display+0x12e>
  {
    case DISP_TIME:
    {
      send(0, nr[ clock.hours >> 4 ] );
 104:	03 e2       	ldi	r16, 0x23	; 35
 106:	11 e0       	ldi	r17, 0x01	; 1
 108:	f8 01       	movw	r30, r16
 10a:	80 81       	ld	r24, Z
 10c:	82 95       	swap	r24
 10e:	8f 70       	andi	r24, 0x0F	; 15
 110:	0f 2e       	mov	r0, r31
 112:	f3 e0       	ldi	r31, 0x03	; 3
 114:	ef 2e       	mov	r14, r31
 116:	f1 e0       	ldi	r31, 0x01	; 1
 118:	ff 2e       	mov	r15, r31
 11a:	f0 2d       	mov	r31, r0
 11c:	f7 01       	movw	r30, r14
 11e:	e8 0f       	add	r30, r24
 120:	f1 1d       	adc	r31, r1
 122:	80 e0       	ldi	r24, 0x00	; 0
 124:	60 81       	ld	r22, Z
 126:	b4 df       	rcall	.-152    	; 0x90 <send>
      send(3, nr[ clock.hours & 0xF ] );
 128:	f8 01       	movw	r30, r16
 12a:	80 81       	ld	r24, Z
 12c:	8f 70       	andi	r24, 0x0F	; 15
 12e:	f7 01       	movw	r30, r14
 130:	e8 0f       	add	r30, r24
 132:	f1 1d       	adc	r31, r1
 134:	83 e0       	ldi	r24, 0x03	; 3
 136:	60 81       	ld	r22, Z
 138:	ab df       	rcall	.-170    	; 0x90 <send>
      send(2, nr[ clock.minutes >> 4 ] );
 13a:	f8 01       	movw	r30, r16
 13c:	82 91       	ld	r24, -Z
 13e:	8f 01       	movw	r16, r30
 140:	82 95       	swap	r24
 142:	8f 70       	andi	r24, 0x0F	; 15
 144:	f7 01       	movw	r30, r14
 146:	e8 0f       	add	r30, r24
 148:	f1 1d       	adc	r31, r1
 14a:	82 e0       	ldi	r24, 0x02	; 2
 14c:	60 81       	ld	r22, Z
 14e:	a0 df       	rcall	.-192    	; 0x90 <send>
      send(1, nr[ clock.minutes & 0xF ] );
 150:	f8 01       	movw	r30, r16
 152:	80 81       	ld	r24, Z
 154:	8f 70       	andi	r24, 0x0F	; 15
 156:	e8 0e       	add	r14, r24
 158:	f1 1c       	adc	r15, r1
 15a:	81 e0       	ldi	r24, 0x01	; 1
 15c:	f7 01       	movw	r30, r14
 15e:	60 81       	ld	r22, Z
 160:	97 df       	rcall	.-210    	; 0x90 <send>
 162:	75 c0       	rjmp	.+234    	; 0x24e <refresh_display+0x16c>
      break;
    }

    case DISP_DATE:
    {
      send(0, nr[ clock.date >> 4 ] );
 164:	05 e2       	ldi	r16, 0x25	; 37
 166:	11 e0       	ldi	r17, 0x01	; 1
 168:	f8 01       	movw	r30, r16
 16a:	80 81       	ld	r24, Z
 16c:	82 95       	swap	r24
 16e:	8f 70       	andi	r24, 0x0F	; 15
 170:	0f 2e       	mov	r0, r31
 172:	f3 e0       	ldi	r31, 0x03	; 3
 174:	ef 2e       	mov	r14, r31
 176:	f1 e0       	ldi	r31, 0x01	; 1
 178:	ff 2e       	mov	r15, r31
 17a:	f0 2d       	mov	r31, r0
 17c:	f7 01       	movw	r30, r14
 17e:	e8 0f       	add	r30, r24
 180:	f1 1d       	adc	r31, r1
 182:	80 e0       	ldi	r24, 0x00	; 0
 184:	60 81       	ld	r22, Z
 186:	84 df       	rcall	.-248    	; 0x90 <send>
      send(3, nr[ clock.date & 0xF ] );
 188:	f8 01       	movw	r30, r16
 18a:	81 91       	ld	r24, Z+
 18c:	8f 01       	movw	r16, r30
 18e:	8f 70       	andi	r24, 0x0F	; 15
 190:	f7 01       	movw	r30, r14
 192:	e8 0f       	add	r30, r24
 194:	f1 1d       	adc	r31, r1
 196:	83 e0       	ldi	r24, 0x03	; 3
 198:	60 81       	ld	r22, Z
 19a:	7a df       	rcall	.-268    	; 0x90 <send>
      send(2, nr[ clock.month >> 4 ] );
 19c:	f8 01       	movw	r30, r16
 19e:	80 81       	ld	r24, Z
 1a0:	82 95       	swap	r24
 1a2:	8f 70       	andi	r24, 0x0F	; 15
 1a4:	f7 01       	movw	r30, r14
 1a6:	e8 0f       	add	r30, r24
 1a8:	f1 1d       	adc	r31, r1
 1aa:	82 e0       	ldi	r24, 0x02	; 2
 1ac:	60 81       	ld	r22, Z
 1ae:	70 df       	rcall	.-288    	; 0x90 <send>
      send(1, nr[ clock.month & 0xF ] );
 1b0:	f8 01       	movw	r30, r16
 1b2:	80 81       	ld	r24, Z
 1b4:	8f 70       	andi	r24, 0x0F	; 15
 1b6:	e8 0e       	add	r14, r24
 1b8:	f1 1c       	adc	r15, r1
 1ba:	81 e0       	ldi	r24, 0x01	; 1
 1bc:	f7 01       	movw	r30, r14
 1be:	60 81       	ld	r22, Z
 1c0:	67 df       	rcall	.-306    	; 0x90 <send>
 1c2:	45 c0       	rjmp	.+138    	; 0x24e <refresh_display+0x16c>
      break;
    }

    case DISP_YEAR:
    {
      send(0, nr[ 2 ] );
 1c4:	05 e0       	ldi	r16, 0x05	; 5
 1c6:	11 e0       	ldi	r17, 0x01	; 1
 1c8:	80 e0       	ldi	r24, 0x00	; 0
 1ca:	f8 01       	movw	r30, r16
 1cc:	60 81       	ld	r22, Z
 1ce:	60 df       	rcall	.-320    	; 0x90 <send>
      send(3, nr[ 0 ] );
 1d0:	02 50       	subi	r16, 0x02	; 2
 1d2:	10 40       	sbci	r17, 0x00	; 0
 1d4:	83 e0       	ldi	r24, 0x03	; 3
 1d6:	f8 01       	movw	r30, r16
 1d8:	60 81       	ld	r22, Z
 1da:	5a df       	rcall	.-332    	; 0x90 <send>
      send(2, nr[ clock.year >> 4 ] );
 1dc:	0f 2e       	mov	r0, r31
 1de:	f7 e2       	ldi	r31, 0x27	; 39
 1e0:	ef 2e       	mov	r14, r31
 1e2:	f1 e0       	ldi	r31, 0x01	; 1
 1e4:	ff 2e       	mov	r15, r31
 1e6:	f0 2d       	mov	r31, r0
 1e8:	f7 01       	movw	r30, r14
 1ea:	80 81       	ld	r24, Z
 1ec:	82 95       	swap	r24
 1ee:	8f 70       	andi	r24, 0x0F	; 15
 1f0:	f8 01       	movw	r30, r16
 1f2:	e8 0f       	add	r30, r24
 1f4:	f1 1d       	adc	r31, r1
 1f6:	82 e0       	ldi	r24, 0x02	; 2
 1f8:	60 81       	ld	r22, Z
 1fa:	4a df       	rcall	.-364    	; 0x90 <send>
      send(1, nr[ clock.year & 0xF ] );
 1fc:	f7 01       	movw	r30, r14
 1fe:	80 81       	ld	r24, Z
 200:	8f 70       	andi	r24, 0x0F	; 15
 202:	08 0f       	add	r16, r24
 204:	11 1d       	adc	r17, r1
 206:	81 e0       	ldi	r24, 0x01	; 1
 208:	f8 01       	movw	r30, r16
 20a:	60 81       	ld	r22, Z
 20c:	41 df       	rcall	.-382    	; 0x90 <send>
 20e:	1f c0       	rjmp	.+62     	; 0x24e <refresh_display+0x16c>
      break;
    }

    case DISP_DAY:
    {
      send(0, 0x7F );
 210:	80 e0       	ldi	r24, 0x00	; 0
 212:	6f e7       	ldi	r22, 0x7F	; 127
 214:	3d df       	rcall	.-390    	; 0x90 <send>
      send(3, 0x7F );
 216:	83 e0       	ldi	r24, 0x03	; 3
 218:	6f e7       	ldi	r22, 0x7F	; 127
 21a:	3a df       	rcall	.-396    	; 0x90 <send>
      send(2, days[ clock.day - 1 ] );
 21c:	0f 2e       	mov	r0, r31
 21e:	f4 e2       	ldi	r31, 0x24	; 36
 220:	ef 2e       	mov	r14, r31
 222:	f1 e0       	ldi	r31, 0x01	; 1
 224:	ff 2e       	mov	r15, r31
 226:	f0 2d       	mov	r31, r0
 228:	f7 01       	movw	r30, r14
 22a:	80 81       	ld	r24, Z
 22c:	0d e0       	ldi	r16, 0x0D	; 13
 22e:	11 e0       	ldi	r17, 0x01	; 1
 230:	f8 01       	movw	r30, r16
 232:	e8 0f       	add	r30, r24
 234:	f1 1d       	adc	r31, r1
 236:	31 97       	sbiw	r30, 0x01	; 1
 238:	82 e0       	ldi	r24, 0x02	; 2
 23a:	60 81       	ld	r22, Z
 23c:	29 df       	rcall	.-430    	; 0x90 <send>
      send(1, days[ clock.day + 6 ] );     
 23e:	f7 01       	movw	r30, r14
 240:	80 81       	ld	r24, Z
 242:	08 0f       	add	r16, r24
 244:	11 1d       	adc	r17, r1
 246:	81 e0       	ldi	r24, 0x01	; 1
 248:	f8 01       	movw	r30, r16
 24a:	66 81       	ldd	r22, Z+6	; 0x06
 24c:	21 df       	rcall	.-446    	; 0x90 <send>
      break;
    }

    default: ;
  }
}
 24e:	1f 91       	pop	r17
 250:	0f 91       	pop	r16
 252:	ff 90       	pop	r15
 254:	ef 90       	pop	r14
 256:	08 95       	ret

00000258 <init>:

void init()
{
  DDRB = 0x01;
 258:	81 e0       	ldi	r24, 0x01	; 1
 25a:	84 b9       	out	0x04, r24	; 4
  PORTB |= (1<<PB6);  // internal pull-up for SQW_OUT
 25c:	e5 e2       	ldi	r30, 0x25	; 37
 25e:	f0 e0       	ldi	r31, 0x00	; 0
 260:	80 81       	ld	r24, Z
 262:	80 64       	ori	r24, 0x40	; 64
 264:	80 83       	st	Z, r24

  DDRC = 0x0F;
 266:	8f e0       	ldi	r24, 0x0F	; 15
 268:	87 b9       	out	0x07, r24	; 7
  PORTC |= 0x30; // internal pull-ups for SDA and SCL
 26a:	e8 e2       	ldi	r30, 0x28	; 40
 26c:	f0 e0       	ldi	r31, 0x00	; 0
 26e:	80 81       	ld	r24, Z
 270:	80 63       	ori	r24, 0x30	; 48
 272:	80 83       	st	Z, r24

  DDRD = 0x7F;
 274:	8f e7       	ldi	r24, 0x7F	; 127
 276:	8a b9       	out	0x0a, r24	; 10
  PORTD = 0;
 278:	1b b8       	out	0x0b, r1	; 11
  PORTC = 0x30 | 0xF; // broadcast
 27a:	8f e3       	ldi	r24, 0x3F	; 63
 27c:	80 83       	st	Z, r24

  PCICR |= (1<<PCIE0);
 27e:	e8 e6       	ldi	r30, 0x68	; 104
 280:	f0 e0       	ldi	r31, 0x00	; 0
 282:	80 81       	ld	r24, Z
 284:	81 60       	ori	r24, 0x01	; 1
 286:	80 83       	st	Z, r24
  PCMSK0 |= (1<<PCINT6);
 288:	eb e6       	ldi	r30, 0x6B	; 107
 28a:	f0 e0       	ldi	r31, 0x00	; 0
 28c:	80 81       	ld	r24, Z
 28e:	80 64       	ori	r24, 0x40	; 64
 290:	80 83       	st	Z, r24

  OCR1A = count;
 292:	80 91 00 01 	lds	r24, 0x0100
 296:	90 91 01 01 	lds	r25, 0x0101
 29a:	90 93 89 00 	sts	0x0089, r25
 29e:	80 93 88 00 	sts	0x0088, r24
  TIMSK1 |= (1<<OCIE1A);
 2a2:	ef e6       	ldi	r30, 0x6F	; 111
 2a4:	f0 e0       	ldi	r31, 0x00	; 0
 2a6:	80 81       	ld	r24, Z
 2a8:	82 60       	ori	r24, 0x02	; 2
 2aa:	80 83       	st	Z, r24
  TCCR1B |= prescaler;
 2ac:	e1 e8       	ldi	r30, 0x81	; 129
 2ae:	f0 e0       	ldi	r31, 0x00	; 0
 2b0:	80 81       	ld	r24, Z
 2b2:	90 91 02 01 	lds	r25, 0x0102
 2b6:	89 2b       	or	r24, r25
 2b8:	80 83       	st	Z, r24
}
 2ba:	08 95       	ret

000002bc <__vector_11>:
  
  sei();
}

ISR(TIMER1_COMPA_vect)
{
 2bc:	1f 92       	push	r1
 2be:	0f 92       	push	r0
 2c0:	0f b6       	in	r0, 0x3f	; 63
 2c2:	0f 92       	push	r0
 2c4:	11 24       	eor	r1, r1
 2c6:	0f 93       	push	r16
 2c8:	1f 93       	push	r17
 2ca:	2f 93       	push	r18
 2cc:	3f 93       	push	r19
 2ce:	4f 93       	push	r20
 2d0:	5f 93       	push	r21
 2d2:	6f 93       	push	r22
 2d4:	7f 93       	push	r23
 2d6:	8f 93       	push	r24
 2d8:	9f 93       	push	r25
 2da:	af 93       	push	r26
 2dc:	bf 93       	push	r27
 2de:	ef 93       	push	r30
 2e0:	ff 93       	push	r31
  TCNT1 = 0;
 2e2:	10 92 85 00 	sts	0x0085, r1
 2e6:	10 92 84 00 	sts	0x0084, r1
  uint8_t keypad = PINB & 0b10000110;
 2ea:	83 b1       	in	r24, 0x03	; 3
 2ec:	48 2f       	mov	r20, r24
 2ee:	46 78       	andi	r20, 0x86	; 134
  cli();
 2f0:	f8 94       	cli
  
  if( keypad == 0b10000110 )  // no key pressed
 2f2:	46 38       	cpi	r20, 0x86	; 134
 2f4:	49 f4       	brne	.+18     	; 0x308 <__vector_11+0x4c>
  {
    OCR1A = count;
 2f6:	80 91 00 01 	lds	r24, 0x0100
 2fa:	90 91 01 01 	lds	r25, 0x0101
 2fe:	90 93 89 00 	sts	0x0089, r25
 302:	80 93 88 00 	sts	0x0088, r24
 306:	e7 c0       	rjmp	.+462    	; 0x4d6 <__vector_11+0x21a>
  }
  else
  {
    OCR1A = 3 * count;
 308:	20 91 00 01 	lds	r18, 0x0100
 30c:	30 91 01 01 	lds	r19, 0x0101
 310:	c9 01       	movw	r24, r18
 312:	88 0f       	add	r24, r24
 314:	99 1f       	adc	r25, r25
 316:	82 0f       	add	r24, r18
 318:	93 1f       	adc	r25, r19
 31a:	90 93 89 00 	sts	0x0089, r25
 31e:	80 93 88 00 	sts	0x0088, r24

    switch(keypad)
 322:	42 38       	cpi	r20, 0x82	; 130
 324:	09 f4       	brne	.+2      	; 0x328 <__vector_11+0x6c>
 326:	72 c0       	rjmp	.+228    	; 0x40c <__vector_11+0x150>
 328:	44 38       	cpi	r20, 0x84	; 132
 32a:	21 f0       	breq	.+8      	; 0x334 <__vector_11+0x78>
 32c:	46 30       	cpi	r20, 0x06	; 6
 32e:	09 f0       	breq	.+2      	; 0x332 <__vector_11+0x76>
 330:	d2 c0       	rjmp	.+420    	; 0x4d6 <__vector_11+0x21a>
 332:	c6 c0       	rjmp	.+396    	; 0x4c0 <__vector_11+0x204>
    {
      case 0b10000100:  // hour++, date++, year++
      {
        if( disp == DISP_TIME )
 334:	80 91 28 01 	lds	r24, 0x0128
 338:	88 23       	and	r24, r24
 33a:	91 f4       	brne	.+36     	; 0x360 <__vector_11+0xa4>
        {
          clock.hours = bcd_inc(clock.hours);
 33c:	03 e2       	ldi	r16, 0x23	; 35
 33e:	11 e0       	ldi	r17, 0x01	; 1
 340:	f8 01       	movw	r30, r16
 342:	80 81       	ld	r24, Z
 344:	5a d3       	rcall	.+1716   	; 0x9fa <bcd_inc>
 346:	f8 01       	movw	r30, r16
 348:	80 83       	st	Z, r24
          if(clock.hours == 0x24)
 34a:	84 32       	cpi	r24, 0x24	; 36
 34c:	11 f4       	brne	.+4      	; 0x352 <__vector_11+0x96>
            clock.hours = 0;
 34e:	10 92 23 01 	sts	0x0123, r1
          q = twi_write_byte( 2, clock.hours );
 352:	82 e0       	ldi	r24, 0x02	; 2
 354:	60 91 23 01 	lds	r22, 0x0123
 358:	20 d3       	rcall	.+1600   	; 0x99a <twi_write_byte>
 35a:	80 93 1e 01 	sts	0x011E, r24
 35e:	54 c0       	rjmp	.+168    	; 0x408 <__vector_11+0x14c>
        }
        else if( disp == DISP_DATE )
 360:	81 30       	cpi	r24, 0x01	; 1
 362:	51 f5       	brne	.+84     	; 0x3b8 <__vector_11+0xfc>
        {
          clock.date = bcd_inc(clock.date);
 364:	05 e2       	ldi	r16, 0x25	; 37
 366:	11 e0       	ldi	r17, 0x01	; 1
 368:	f8 01       	movw	r30, r16
 36a:	80 81       	ld	r24, Z
 36c:	46 d3       	rcall	.+1676   	; 0x9fa <bcd_inc>
 36e:	28 2f       	mov	r18, r24
 370:	f8 01       	movw	r30, r16
 372:	81 93       	st	Z+, r24
          switch(clock.month)
 374:	80 81       	ld	r24, Z
 376:	90 e0       	ldi	r25, 0x00	; 0
 378:	fc 01       	movw	r30, r24
 37a:	31 97       	sbiw	r30, 0x01	; 1
 37c:	e2 31       	cpi	r30, 0x12	; 18
 37e:	f1 05       	cpc	r31, r1
 380:	78 f4       	brcc	.+30     	; 0x3a0 <__vector_11+0xe4>
 382:	e6 5e       	subi	r30, 0xE6	; 230
 384:	ff 4f       	sbci	r31, 0xFF	; 255
 386:	09 94       	ijmp
          {
            case 0x01: case 0x03: case 0x05: case 0x07: case 0x08: case 0x10: case 0x12:
              if(clock.date == 0x32)
 388:	22 33       	cpi	r18, 0x32	; 50
 38a:	79 f4       	brne	.+30     	; 0x3aa <__vector_11+0xee>
                clock.date = 1;
 38c:	81 e0       	ldi	r24, 0x01	; 1
 38e:	80 93 25 01 	sts	0x0125, r24
 392:	0b c0       	rjmp	.+22     	; 0x3aa <__vector_11+0xee>
              break;
            case 0x04: case 0x06: case 0x09: case 0x11:
              if(clock.date == 0x31)
 394:	21 33       	cpi	r18, 0x31	; 49
 396:	49 f4       	brne	.+18     	; 0x3aa <__vector_11+0xee>
                clock.date = 1;
 398:	81 e0       	ldi	r24, 0x01	; 1
 39a:	80 93 25 01 	sts	0x0125, r24
 39e:	05 c0       	rjmp	.+10     	; 0x3aa <__vector_11+0xee>
              break;
            default :
              if(clock.date == 0x29)
 3a0:	29 32       	cpi	r18, 0x29	; 41
 3a2:	19 f4       	brne	.+6      	; 0x3aa <__vector_11+0xee>
                clock.date = 1;
 3a4:	81 e0       	ldi	r24, 0x01	; 1
 3a6:	80 93 25 01 	sts	0x0125, r24
              break;
          }
          q = twi_write_byte( 4, clock.date );
 3aa:	84 e0       	ldi	r24, 0x04	; 4
 3ac:	60 91 25 01 	lds	r22, 0x0125
 3b0:	f4 d2       	rcall	.+1512   	; 0x99a <twi_write_byte>
 3b2:	80 93 1e 01 	sts	0x011E, r24
 3b6:	28 c0       	rjmp	.+80     	; 0x408 <__vector_11+0x14c>
        }
        else if( disp == DISP_YEAR )
 3b8:	82 30       	cpi	r24, 0x02	; 2
 3ba:	99 f4       	brne	.+38     	; 0x3e2 <__vector_11+0x126>
        {
          clock.year = bcd_inc(clock.year);
 3bc:	07 e2       	ldi	r16, 0x27	; 39
 3be:	11 e0       	ldi	r17, 0x01	; 1
 3c0:	f8 01       	movw	r30, r16
 3c2:	80 81       	ld	r24, Z
 3c4:	1a d3       	rcall	.+1588   	; 0x9fa <bcd_inc>
 3c6:	f8 01       	movw	r30, r16
 3c8:	80 83       	st	Z, r24
          if(clock.year == 0x51 )
 3ca:	81 35       	cpi	r24, 0x51	; 81
 3cc:	19 f4       	brne	.+6      	; 0x3d4 <__vector_11+0x118>
            clock.year = 0x11;
 3ce:	81 e1       	ldi	r24, 0x11	; 17
 3d0:	80 93 27 01 	sts	0x0127, r24
          q = twi_write_byte( 6, clock.year );
 3d4:	86 e0       	ldi	r24, 0x06	; 6
 3d6:	60 91 27 01 	lds	r22, 0x0127
 3da:	df d2       	rcall	.+1470   	; 0x99a <twi_write_byte>
 3dc:	80 93 1e 01 	sts	0x011E, r24
 3e0:	13 c0       	rjmp	.+38     	; 0x408 <__vector_11+0x14c>
        }
        else if( disp == DISP_DAY )
 3e2:	83 30       	cpi	r24, 0x03	; 3
 3e4:	89 f4       	brne	.+34     	; 0x408 <__vector_11+0x14c>
        {
          ( clock.day == 7 ) ? clock.day = 1 : clock.day++;
 3e6:	80 91 24 01 	lds	r24, 0x0124
 3ea:	87 30       	cpi	r24, 0x07	; 7
 3ec:	21 f4       	brne	.+8      	; 0x3f6 <__vector_11+0x13a>
 3ee:	81 e0       	ldi	r24, 0x01	; 1
 3f0:	80 93 24 01 	sts	0x0124, r24
 3f4:	03 c0       	rjmp	.+6      	; 0x3fc <__vector_11+0x140>
 3f6:	8f 5f       	subi	r24, 0xFF	; 255
 3f8:	80 93 24 01 	sts	0x0124, r24
          q = twi_write_byte( 3, clock.day );
 3fc:	83 e0       	ldi	r24, 0x03	; 3
 3fe:	60 91 24 01 	lds	r22, 0x0124
 402:	cb d2       	rcall	.+1430   	; 0x99a <twi_write_byte>
 404:	80 93 1e 01 	sts	0x011E, r24
        }

        refresh_display();
 408:	6c de       	rcall	.-808    	; 0xe2 <refresh_display>
 40a:	65 c0       	rjmp	.+202    	; 0x4d6 <__vector_11+0x21a>
        break;
      }

      case 0b10000010:  // minute++, month++, year--
      {
        if( disp == DISP_TIME )
 40c:	80 91 28 01 	lds	r24, 0x0128
 410:	88 23       	and	r24, r24
 412:	b9 f4       	brne	.+46     	; 0x442 <__vector_11+0x186>
        {
          clock.minutes = bcd_inc(clock.minutes);
 414:	02 e2       	ldi	r16, 0x22	; 34
 416:	11 e0       	ldi	r17, 0x01	; 1
 418:	f8 01       	movw	r30, r16
 41a:	80 81       	ld	r24, Z
 41c:	ee d2       	rcall	.+1500   	; 0x9fa <bcd_inc>
 41e:	f8 01       	movw	r30, r16
 420:	80 83       	st	Z, r24
          if(clock.minutes == 0x60)
 422:	80 36       	cpi	r24, 0x60	; 96
 424:	11 f4       	brne	.+4      	; 0x42a <__vector_11+0x16e>
            clock.minutes = 0;
 426:	10 92 22 01 	sts	0x0122, r1
          q = twi_write_byte( 0, 0 );
 42a:	80 e0       	ldi	r24, 0x00	; 0
 42c:	60 e0       	ldi	r22, 0x00	; 0
 42e:	b5 d2       	rcall	.+1386   	; 0x99a <twi_write_byte>
 430:	80 93 1e 01 	sts	0x011E, r24
          q = twi_write_byte( 1, clock.minutes );
 434:	81 e0       	ldi	r24, 0x01	; 1
 436:	60 91 22 01 	lds	r22, 0x0122
 43a:	af d2       	rcall	.+1374   	; 0x99a <twi_write_byte>
 43c:	80 93 1e 01 	sts	0x011E, r24
 440:	3d c0       	rjmp	.+122    	; 0x4bc <__vector_11+0x200>
        }
        else if( disp == DISP_DATE )
 442:	81 30       	cpi	r24, 0x01	; 1
 444:	99 f4       	brne	.+38     	; 0x46c <__vector_11+0x1b0>
        {
          clock.month = bcd_inc(clock.month);
 446:	06 e2       	ldi	r16, 0x26	; 38
 448:	11 e0       	ldi	r17, 0x01	; 1
 44a:	f8 01       	movw	r30, r16
 44c:	80 81       	ld	r24, Z
 44e:	d5 d2       	rcall	.+1450   	; 0x9fa <bcd_inc>
 450:	f8 01       	movw	r30, r16
 452:	80 83       	st	Z, r24
          if( clock.month == 0x13 )
 454:	83 31       	cpi	r24, 0x13	; 19
 456:	19 f4       	brne	.+6      	; 0x45e <__vector_11+0x1a2>
            clock.month = 1;
 458:	81 e0       	ldi	r24, 0x01	; 1
 45a:	80 93 26 01 	sts	0x0126, r24
          q = twi_write_byte( 5, clock.month );
 45e:	85 e0       	ldi	r24, 0x05	; 5
 460:	60 91 26 01 	lds	r22, 0x0126
 464:	9a d2       	rcall	.+1332   	; 0x99a <twi_write_byte>
 466:	80 93 1e 01 	sts	0x011E, r24
 46a:	28 c0       	rjmp	.+80     	; 0x4bc <__vector_11+0x200>
        }
        else if( disp == DISP_YEAR )
 46c:	82 30       	cpi	r24, 0x02	; 2
 46e:	99 f4       	brne	.+38     	; 0x496 <__vector_11+0x1da>
        {
          clock.year = bcd_dec(clock.year);
 470:	07 e2       	ldi	r16, 0x27	; 39
 472:	11 e0       	ldi	r17, 0x01	; 1
 474:	f8 01       	movw	r30, r16
 476:	80 81       	ld	r24, Z
 478:	cc d2       	rcall	.+1432   	; 0xa12 <bcd_dec>
 47a:	f8 01       	movw	r30, r16
 47c:	80 83       	st	Z, r24
          if( clock.year == 0x10 )
 47e:	80 31       	cpi	r24, 0x10	; 16
 480:	19 f4       	brne	.+6      	; 0x488 <__vector_11+0x1cc>
            clock.year = 0x50;
 482:	80 e5       	ldi	r24, 0x50	; 80
 484:	80 93 27 01 	sts	0x0127, r24
          q = twi_write_byte( 6, clock.year );
 488:	86 e0       	ldi	r24, 0x06	; 6
 48a:	60 91 27 01 	lds	r22, 0x0127
 48e:	85 d2       	rcall	.+1290   	; 0x99a <twi_write_byte>
 490:	80 93 1e 01 	sts	0x011E, r24
 494:	13 c0       	rjmp	.+38     	; 0x4bc <__vector_11+0x200>
        }
        else if( disp == DISP_DAY )
 496:	83 30       	cpi	r24, 0x03	; 3
 498:	89 f4       	brne	.+34     	; 0x4bc <__vector_11+0x200>
        {
          ( clock.day == 1 ) ? clock.day = 7 : clock.day--;
 49a:	80 91 24 01 	lds	r24, 0x0124
 49e:	81 30       	cpi	r24, 0x01	; 1
 4a0:	21 f4       	brne	.+8      	; 0x4aa <__vector_11+0x1ee>
 4a2:	87 e0       	ldi	r24, 0x07	; 7
 4a4:	80 93 24 01 	sts	0x0124, r24
 4a8:	03 c0       	rjmp	.+6      	; 0x4b0 <__vector_11+0x1f4>
 4aa:	81 50       	subi	r24, 0x01	; 1
 4ac:	80 93 24 01 	sts	0x0124, r24
          q = twi_write_byte( 3, clock.day );
 4b0:	83 e0       	ldi	r24, 0x03	; 3
 4b2:	60 91 24 01 	lds	r22, 0x0124
 4b6:	71 d2       	rcall	.+1250   	; 0x99a <twi_write_byte>
 4b8:	80 93 1e 01 	sts	0x011E, r24
        }

        refresh_display();
 4bc:	12 de       	rcall	.-988    	; 0xe2 <refresh_display>
 4be:	0b c0       	rjmp	.+22     	; 0x4d6 <__vector_11+0x21a>
        break;
      }

      case 0b00000110:  // switch display mode
      {
        (disp == 3) ? disp = 0 : disp++;
 4c0:	80 91 28 01 	lds	r24, 0x0128
 4c4:	83 30       	cpi	r24, 0x03	; 3
 4c6:	19 f4       	brne	.+6      	; 0x4ce <__vector_11+0x212>
 4c8:	10 92 28 01 	sts	0x0128, r1
 4cc:	03 c0       	rjmp	.+6      	; 0x4d4 <__vector_11+0x218>
 4ce:	8f 5f       	subi	r24, 0xFF	; 255
 4d0:	80 93 28 01 	sts	0x0128, r24
        refresh_display();
 4d4:	06 de       	rcall	.-1012   	; 0xe2 <refresh_display>
      }

      default: ;
    }
  }
  sei();
 4d6:	78 94       	sei
}
 4d8:	ff 91       	pop	r31
 4da:	ef 91       	pop	r30
 4dc:	bf 91       	pop	r27
 4de:	af 91       	pop	r26
 4e0:	9f 91       	pop	r25
 4e2:	8f 91       	pop	r24
 4e4:	7f 91       	pop	r23
 4e6:	6f 91       	pop	r22
 4e8:	5f 91       	pop	r21
 4ea:	4f 91       	pop	r20
 4ec:	3f 91       	pop	r19
 4ee:	2f 91       	pop	r18
 4f0:	1f 91       	pop	r17
 4f2:	0f 91       	pop	r16
 4f4:	0f 90       	pop	r0
 4f6:	0f be       	out	0x3f, r0	; 63
 4f8:	0f 90       	pop	r0
 4fa:	1f 90       	pop	r1
 4fc:	18 95       	reti

000004fe <__vector_3>:

  return 0;
}

ISR(PCINT0_vect)
{
 4fe:	1f 92       	push	r1
 500:	0f 92       	push	r0
 502:	0f b6       	in	r0, 0x3f	; 63
 504:	0f 92       	push	r0
 506:	11 24       	eor	r1, r1
 508:	2f 93       	push	r18
 50a:	3f 93       	push	r19
 50c:	4f 93       	push	r20
 50e:	5f 93       	push	r21
 510:	6f 93       	push	r22
 512:	7f 93       	push	r23
 514:	8f 93       	push	r24
 516:	9f 93       	push	r25
 518:	af 93       	push	r26
 51a:	bf 93       	push	r27
 51c:	ef 93       	push	r30
 51e:	ff 93       	push	r31
 520:	df 93       	push	r29
 522:	cf 93       	push	r28
 524:	cd b7       	in	r28, 0x3d	; 61
 526:	de b7       	in	r29, 0x3e	; 62
 528:	27 97       	sbiw	r28, 0x07	; 7
 52a:	de bf       	out	0x3e, r29	; 62
 52c:	cd bf       	out	0x3d, r28	; 61
  cli();
 52e:	f8 94       	cli
  PORTB = (PORTB & 0xFE) | ((PINB>>6) & 1);
 530:	a5 e2       	ldi	r26, 0x25	; 37
 532:	b0 e0       	ldi	r27, 0x00	; 0
 534:	9c 91       	ld	r25, X
 536:	e3 e2       	ldi	r30, 0x23	; 35
 538:	f0 e0       	ldi	r31, 0x00	; 0
 53a:	80 81       	ld	r24, Z
 53c:	82 95       	swap	r24
 53e:	86 95       	lsr	r24
 540:	86 95       	lsr	r24
 542:	83 70       	andi	r24, 0x03	; 3
 544:	81 70       	andi	r24, 0x01	; 1
 546:	9e 7f       	andi	r25, 0xFE	; 254
 548:	89 2b       	or	r24, r25
 54a:	8c 93       	st	X, r24
  if( ((PINB>>6) & 1) == 0 )
 54c:	80 81       	ld	r24, Z
 54e:	82 95       	swap	r24
 550:	86 95       	lsr	r24
 552:	86 95       	lsr	r24
 554:	83 70       	andi	r24, 0x03	; 3
 556:	80 fd       	sbrc	r24, 0
 558:	05 c0       	rjmp	.+10     	; 0x564 <__stack+0x65>
    seconds++;
 55a:	80 91 20 01 	lds	r24, 0x0120
 55e:	8f 5f       	subi	r24, 0xFF	; 255
 560:	80 93 20 01 	sts	0x0120, r24
  
  if( seconds == 60 )
 564:	80 91 20 01 	lds	r24, 0x0120
 568:	8c 33       	cpi	r24, 0x3C	; 60
 56a:	09 f0       	breq	.+2      	; 0x56e <__stack+0x6f>
 56c:	66 c0       	rjmp	.+204    	; 0x63a <__stack+0x13b>
  {
    clock = rtc_read();
 56e:	53 d1       	rcall	.+678    	; 0x816 <rtc_read>
 570:	29 83       	std	Y+1, r18	; 0x01
 572:	3a 83       	std	Y+2, r19	; 0x02
 574:	4b 83       	std	Y+3, r20	; 0x03
 576:	5c 83       	std	Y+4, r21	; 0x04
 578:	6d 83       	std	Y+5, r22	; 0x05
 57a:	7e 83       	std	Y+6, r23	; 0x06
 57c:	8f 83       	std	Y+7, r24	; 0x07
 57e:	a1 e2       	ldi	r26, 0x21	; 33
 580:	b1 e0       	ldi	r27, 0x01	; 1
 582:	fe 01       	movw	r30, r28
 584:	31 96       	adiw	r30, 0x01	; 1
 586:	87 e0       	ldi	r24, 0x07	; 7
 588:	01 90       	ld	r0, Z+
 58a:	0d 92       	st	X+, r0
 58c:	81 50       	subi	r24, 0x01	; 1
 58e:	e1 f7       	brne	.-8      	; 0x588 <__stack+0x89>
    seconds = (clock.seconds >> 4) * 10 + (clock.seconds & 0xF);
 590:	e1 e2       	ldi	r30, 0x21	; 33
 592:	f1 e0       	ldi	r31, 0x01	; 1
 594:	20 81       	ld	r18, Z
 596:	82 2f       	mov	r24, r18
 598:	82 95       	swap	r24
 59a:	8f 70       	andi	r24, 0x0F	; 15
 59c:	3a e0       	ldi	r19, 0x0A	; 10
 59e:	83 9f       	mul	r24, r19
 5a0:	c0 01       	movw	r24, r0
 5a2:	11 24       	eor	r1, r1
 5a4:	2f 70       	andi	r18, 0x0F	; 15
 5a6:	28 0f       	add	r18, r24
 5a8:	20 93 20 01 	sts	0x0120, r18
    
    // DST - on
    if( clock.month == 0x03 )
 5ac:	85 81       	ldd	r24, Z+5	; 0x05
 5ae:	83 30       	cpi	r24, 0x03	; 3
 5b0:	e9 f4       	brne	.+58     	; 0x5ec <__stack+0xed>
      if( clock.date > 0x25 )
 5b2:	80 91 25 01 	lds	r24, 0x0125
 5b6:	86 32       	cpi	r24, 0x26	; 38
 5b8:	c8 f0       	brcs	.+50     	; 0x5ec <__stack+0xed>
        if( clock.day == 1 )
 5ba:	80 91 24 01 	lds	r24, 0x0124
 5be:	81 30       	cpi	r24, 0x01	; 1
 5c0:	d9 f5       	brne	.+118    	; 0x638 <__stack+0x139>
          if( clock.hours == 3 )
 5c2:	80 91 23 01 	lds	r24, 0x0123
 5c6:	83 30       	cpi	r24, 0x03	; 3
 5c8:	b9 f5       	brne	.+110    	; 0x638 <__stack+0x139>
            if( clock.minutes == 0 )
 5ca:	80 91 22 01 	lds	r24, 0x0122
 5ce:	88 23       	and	r24, r24
 5d0:	99 f5       	brne	.+102    	; 0x638 <__stack+0x139>
              if( seconds == 0 )
 5d2:	22 23       	and	r18, r18
 5d4:	89 f5       	brne	.+98     	; 0x638 <__stack+0x139>
              {
                DST = 1;
 5d6:	81 e0       	ldi	r24, 0x01	; 1
 5d8:	80 93 1b 01 	sts	0x011B, r24
                clock.hours++;
 5dc:	84 e0       	ldi	r24, 0x04	; 4
 5de:	80 93 23 01 	sts	0x0123, r24
                q = twi_write_byte(2,clock.hours);
 5e2:	82 e0       	ldi	r24, 0x02	; 2
 5e4:	64 e0       	ldi	r22, 0x04	; 4
 5e6:	d9 d1       	rcall	.+946    	; 0x99a <twi_write_byte>
 5e8:	80 93 1e 01 	sts	0x011E, r24
              }

    // DST - off
    if( (clock.month == 0x10) && (DST == 1) )
 5ec:	80 91 26 01 	lds	r24, 0x0126
 5f0:	80 31       	cpi	r24, 0x10	; 16
 5f2:	11 f5       	brne	.+68     	; 0x638 <__stack+0x139>
 5f4:	80 91 1b 01 	lds	r24, 0x011B
 5f8:	81 30       	cpi	r24, 0x01	; 1
 5fa:	f1 f4       	brne	.+60     	; 0x638 <__stack+0x139>
      if( clock.date > 0x25 )
 5fc:	80 91 25 01 	lds	r24, 0x0125
 600:	86 32       	cpi	r24, 0x26	; 38
 602:	d0 f0       	brcs	.+52     	; 0x638 <__stack+0x139>
        if( clock.day == 1 )
 604:	80 91 24 01 	lds	r24, 0x0124
 608:	81 30       	cpi	r24, 0x01	; 1
 60a:	b1 f4       	brne	.+44     	; 0x638 <__stack+0x139>
          if( clock.hours == 4 )
 60c:	80 91 23 01 	lds	r24, 0x0123
 610:	84 30       	cpi	r24, 0x04	; 4
 612:	91 f4       	brne	.+36     	; 0x638 <__stack+0x139>
            if( clock.minutes == 0 )
 614:	80 91 22 01 	lds	r24, 0x0122
 618:	88 23       	and	r24, r24
 61a:	71 f4       	brne	.+28     	; 0x638 <__stack+0x139>
              if( seconds == 0 )
 61c:	80 91 20 01 	lds	r24, 0x0120
 620:	88 23       	and	r24, r24
 622:	51 f4       	brne	.+20     	; 0x638 <__stack+0x139>
              {
                DST = 0;
 624:	10 92 1b 01 	sts	0x011B, r1
                clock.hours--;
 628:	83 e0       	ldi	r24, 0x03	; 3
 62a:	80 93 23 01 	sts	0x0123, r24
                q = twi_write_byte(2,clock.hours);
 62e:	82 e0       	ldi	r24, 0x02	; 2
 630:	63 e0       	ldi	r22, 0x03	; 3
 632:	b3 d1       	rcall	.+870    	; 0x99a <twi_write_byte>
 634:	80 93 1e 01 	sts	0x011E, r24
              }

    refresh_display();
 638:	54 dd       	rcall	.-1368   	; 0xe2 <refresh_display>
  }
  
  sei();
 63a:	78 94       	sei
}
 63c:	27 96       	adiw	r28, 0x07	; 7
 63e:	de bf       	out	0x3e, r29	; 62
 640:	cd bf       	out	0x3d, r28	; 61
 642:	cf 91       	pop	r28
 644:	df 91       	pop	r29
 646:	ff 91       	pop	r31
 648:	ef 91       	pop	r30
 64a:	bf 91       	pop	r27
 64c:	af 91       	pop	r26
 64e:	9f 91       	pop	r25
 650:	8f 91       	pop	r24
 652:	7f 91       	pop	r23
 654:	6f 91       	pop	r22
 656:	5f 91       	pop	r21
 658:	4f 91       	pop	r20
 65a:	3f 91       	pop	r19
 65c:	2f 91       	pop	r18
 65e:	0f 90       	pop	r0
 660:	0f be       	out	0x3f, r0	; 63
 662:	0f 90       	pop	r0
 664:	1f 90       	pop	r1
 666:	18 95       	reti

00000668 <main>:
  TIMSK1 |= (1<<OCIE1A);
  TCCR1B |= prescaler;
}

int main()
{
 668:	df 93       	push	r29
 66a:	cf 93       	push	r28
 66c:	cd b7       	in	r28, 0x3d	; 61
 66e:	de b7       	in	r29, 0x3e	; 62
 670:	27 97       	sbiw	r28, 0x07	; 7
 672:	0f b6       	in	r0, 0x3f	; 63
 674:	f8 94       	cli
 676:	de bf       	out	0x3e, r29	; 62
 678:	0f be       	out	0x3f, r0	; 63
 67a:	cd bf       	out	0x3d, r28	; 61
  cli();
 67c:	f8 94       	cli
  init();  
 67e:	ec dd       	rcall	.-1064   	; 0x258 <init>
	sei();
 680:	78 94       	sei

  clock = rtc_read();
 682:	c9 d0       	rcall	.+402    	; 0x816 <rtc_read>
 684:	29 83       	std	Y+1, r18	; 0x01
 686:	3a 83       	std	Y+2, r19	; 0x02
 688:	4b 83       	std	Y+3, r20	; 0x03
 68a:	5c 83       	std	Y+4, r21	; 0x04
 68c:	6d 83       	std	Y+5, r22	; 0x05
 68e:	7e 83       	std	Y+6, r23	; 0x06
 690:	8f 83       	std	Y+7, r24	; 0x07
 692:	a1 e2       	ldi	r26, 0x21	; 33
 694:	b1 e0       	ldi	r27, 0x01	; 1
 696:	fe 01       	movw	r30, r28
 698:	31 96       	adiw	r30, 0x01	; 1
 69a:	87 e0       	ldi	r24, 0x07	; 7
 69c:	01 90       	ld	r0, Z+
 69e:	0d 92       	st	X+, r0
 6a0:	81 50       	subi	r24, 0x01	; 1
 6a2:	e1 f7       	brne	.-8      	; 0x69c <main+0x34>
  seconds = (clock.seconds >> 4) * 10 + (clock.seconds & 0xF);
 6a4:	80 91 21 01 	lds	r24, 0x0121
 6a8:	28 2f       	mov	r18, r24
 6aa:	22 95       	swap	r18
 6ac:	2f 70       	andi	r18, 0x0F	; 15
 6ae:	9a e0       	ldi	r25, 0x0A	; 10
 6b0:	29 9f       	mul	r18, r25
 6b2:	90 01       	movw	r18, r0
 6b4:	11 24       	eor	r1, r1
 6b6:	8f 70       	andi	r24, 0x0F	; 15
 6b8:	82 0f       	add	r24, r18
 6ba:	80 93 20 01 	sts	0x0120, r24
  q = twi_write_byte(7,( 0<<OUT | 1<<SQWE | 0<<RS1 | 0<<RS0 )); // Set DS1307 square wave output on, freq = 1Hz
 6be:	87 e0       	ldi	r24, 0x07	; 7
 6c0:	60 e1       	ldi	r22, 0x10	; 16
 6c2:	6b d1       	rcall	.+726    	; 0x99a <twi_write_byte>
 6c4:	80 93 1e 01 	sts	0x011E, r24
  refresh_display();
 6c8:	0c dd       	rcall	.-1512   	; 0xe2 <refresh_display>
 6ca:	ff cf       	rjmp	.-2      	; 0x6ca <main+0x62>

000006cc <delay>:

void delay(int cycles)
{
  while(cycles > 0)
    cycles--;
}
 6cc:	08 95       	ret

000006ce <twi_start>:

// ================= INITIALIZATION ==================

char twi_start()
{
  TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);   // Send START condition
 6ce:	84 ea       	ldi	r24, 0xA4	; 164
 6d0:	80 93 bc 00 	sts	0x00BC, r24
  while (!(TWCR & (1<<TWINT)));             // Wait for TWINT flag set. This indicates that the START condition has been transmitted
 6d4:	ec eb       	ldi	r30, 0xBC	; 188
 6d6:	f0 e0       	ldi	r31, 0x00	; 0
 6d8:	80 81       	ld	r24, Z
 6da:	88 23       	and	r24, r24
 6dc:	ec f7       	brge	.-6      	; 0x6d8 <twi_start+0xa>
  TWI_S = (TWSR & 0xF8);
 6de:	80 91 b9 00 	lds	r24, 0x00B9
 6e2:	88 7f       	andi	r24, 0xF8	; 248
 6e4:	80 93 29 01 	sts	0x0129, r24
  if ((TWI_S != START) && (TWI_S != RESTART))  // Check value of TWI Status Register. Mask prescaler bits. 
 6e8:	88 30       	cpi	r24, 0x08	; 8
 6ea:	11 f4       	brne	.+4      	; 0x6f0 <twi_start+0x22>
 6ec:	90 e0       	ldi	r25, 0x00	; 0
 6ee:	06 c0       	rjmp	.+12     	; 0x6fc <twi_start+0x2e>
 6f0:	90 e0       	ldi	r25, 0x00	; 0
 6f2:	80 31       	cpi	r24, 0x10	; 16
 6f4:	09 f4       	brne	.+2      	; 0x6f8 <twi_start+0x2a>
 6f6:	91 e0       	ldi	r25, 0x01	; 1
 6f8:	81 e0       	ldi	r24, 0x01	; 1
 6fa:	98 27       	eor	r25, r24
    return 1;                                // If status different from START go to ERROR
  else
    return 0;
}
 6fc:	89 2f       	mov	r24, r25
 6fe:	08 95       	ret

00000700 <twi_stop>:

char twi_stop()
{
  TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
 700:	84 e9       	ldi	r24, 0x94	; 148
 702:	80 93 bc 00 	sts	0x00BC, r24
  //delay(20);
  return 0;
}
 706:	80 e0       	ldi	r24, 0x00	; 0
 708:	08 95       	ret

0000070a <twi_set_read>:

// =============== READING ====================

char twi_set_read()
{
  if(twi_start() != 0)
 70a:	e1 df       	rcall	.-62     	; 0x6ce <twi_start>
 70c:	88 23       	and	r24, r24
 70e:	11 f0       	breq	.+4      	; 0x714 <twi_set_read+0xa>
 710:	91 e0       	ldi	r25, 0x01	; 1
 712:	14 c0       	rjmp	.+40     	; 0x73c <twi_set_read+0x32>
    return 1;
  
  TWDR = SLA_R;                             // Load slave address (SLA) + read bit(R) into TWDR Register.
 714:	81 ed       	ldi	r24, 0xD1	; 209
 716:	80 93 bb 00 	sts	0x00BB, r24
  TWCR = (1<<TWINT) | (1<<TWEN);            // Clear TWINT bit in TWCR to start transmission of address
 71a:	84 e8       	ldi	r24, 0x84	; 132
 71c:	80 93 bc 00 	sts	0x00BC, r24
  while (!(TWCR & (1<<TWINT)));             // Wait for TWINT flag set. This indicates that the SLA+W has been transmitted, and ACK/NACK has been received.
 720:	ec eb       	ldi	r30, 0xBC	; 188
 722:	f0 e0       	ldi	r31, 0x00	; 0
 724:	80 81       	ld	r24, Z
 726:	88 23       	and	r24, r24
 728:	ec f7       	brge	.-6      	; 0x724 <twi_set_read+0x1a>
  TWI_S = (TWSR & 0xF8);
 72a:	80 91 b9 00 	lds	r24, 0x00B9
 72e:	88 7f       	andi	r24, 0xF8	; 248
 730:	80 93 29 01 	sts	0x0129, r24
 734:	90 e0       	ldi	r25, 0x00	; 0
 736:	80 34       	cpi	r24, 0x40	; 64
 738:	09 f0       	breq	.+2      	; 0x73c <twi_set_read+0x32>
 73a:	91 e0       	ldi	r25, 0x01	; 1
  if (TWI_S != MR_SLA_ACK)          // Check value of TWI Status Register. Mask prescaler bits.
    return 1;                                // If status different from ST_SLA_ACK go to ERROR
  else
    return 0;
}
 73c:	89 2f       	mov	r24, r25
 73e:	08 95       	ret

00000740 <twi_read>:

int twi_read(char ack)
{
  if(ack)
 740:	88 23       	and	r24, r24
 742:	a1 f0       	breq	.+40     	; 0x76c <twi_read+0x2c>
  {
    TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);  // If NOT the last read byte, send ACK after read
 744:	84 ec       	ldi	r24, 0xC4	; 196
 746:	80 93 bc 00 	sts	0x00BC, r24

    while (!(TWCR & (1<<TWINT)));
 74a:	ec eb       	ldi	r30, 0xBC	; 188
 74c:	f0 e0       	ldi	r31, 0x00	; 0
 74e:	80 81       	ld	r24, Z
 750:	88 23       	and	r24, r24
 752:	ec f7       	brge	.-6      	; 0x74e <twi_read+0xe>
    TWI_S = (TWSR & 0xF8);
 754:	80 91 b9 00 	lds	r24, 0x00B9
 758:	88 7f       	andi	r24, 0xF8	; 248
 75a:	80 93 29 01 	sts	0x0129, r24
    
    if(TWI_S != MR_DATA_ACK) 
 75e:	80 35       	cpi	r24, 0x50	; 80
 760:	c9 f4       	brne	.+50     	; 0x794 <twi_read+0x54>
      return ((1<<8) | 0x00);
    else
      return TWDR;
 762:	80 91 bb 00 	lds	r24, 0x00BB
 766:	28 2f       	mov	r18, r24
 768:	30 e0       	ldi	r19, 0x00	; 0
 76a:	16 c0       	rjmp	.+44     	; 0x798 <twi_read+0x58>
  }
  else
  {
    TWCR = (1<<TWINT) | (1<<TWEN) | (0<<TWEA);  // If the last read byte, send NACK after read
 76c:	84 e8       	ldi	r24, 0x84	; 132
 76e:	80 93 bc 00 	sts	0x00BC, r24

    while (!(TWCR & (1<<TWINT)));
 772:	ec eb       	ldi	r30, 0xBC	; 188
 774:	f0 e0       	ldi	r31, 0x00	; 0
 776:	80 81       	ld	r24, Z
 778:	88 23       	and	r24, r24
 77a:	ec f7       	brge	.-6      	; 0x776 <twi_read+0x36>
    TWI_S = (TWSR & 0xF8);
 77c:	80 91 b9 00 	lds	r24, 0x00B9
 780:	88 7f       	andi	r24, 0xF8	; 248
 782:	80 93 29 01 	sts	0x0129, r24
    
    if(TWI_S != MR_DATA_NACK) 
 786:	88 35       	cpi	r24, 0x58	; 88
 788:	29 f4       	brne	.+10     	; 0x794 <twi_read+0x54>
      return ((1<<8) | 0x00);
    else
      return TWDR;
 78a:	80 91 bb 00 	lds	r24, 0x00BB
 78e:	28 2f       	mov	r18, r24
 790:	30 e0       	ldi	r19, 0x00	; 0
 792:	02 c0       	rjmp	.+4      	; 0x798 <twi_read+0x58>
 794:	20 e0       	ldi	r18, 0x00	; 0
 796:	31 e0       	ldi	r19, 0x01	; 1
  }
}
 798:	82 2f       	mov	r24, r18
 79a:	93 2f       	mov	r25, r19
 79c:	08 95       	ret

0000079e <twi_set_write>:

// ==================== WRITING =========================

char twi_set_write()
{
  if(twi_start() != 0)
 79e:	97 df       	rcall	.-210    	; 0x6ce <twi_start>
 7a0:	88 23       	and	r24, r24
 7a2:	11 f0       	breq	.+4      	; 0x7a8 <twi_set_write+0xa>
 7a4:	91 e0       	ldi	r25, 0x01	; 1
 7a6:	14 c0       	rjmp	.+40     	; 0x7d0 <twi_set_write+0x32>
    return 1;
  
  TWDR = SLA_W;                             // Load slave address (SLA) + write bit(W) into TWDR Register.
 7a8:	80 ed       	ldi	r24, 0xD0	; 208
 7aa:	80 93 bb 00 	sts	0x00BB, r24
  TWCR = (1<<TWINT) | (1<<TWEN);            // Clear TWINT bit in TWCR to start transmission of address
 7ae:	84 e8       	ldi	r24, 0x84	; 132
 7b0:	80 93 bc 00 	sts	0x00BC, r24
  while (!(TWCR & (1<<TWINT)));             // Wait for TWINT flag set. This indicates that the SLA+W has been transmitted, and ACK/NACK has been received.
 7b4:	ec eb       	ldi	r30, 0xBC	; 188
 7b6:	f0 e0       	ldi	r31, 0x00	; 0
 7b8:	80 81       	ld	r24, Z
 7ba:	88 23       	and	r24, r24
 7bc:	ec f7       	brge	.-6      	; 0x7b8 <twi_set_write+0x1a>
  TWI_S = (TWSR & 0xF8);
 7be:	80 91 b9 00 	lds	r24, 0x00B9
 7c2:	88 7f       	andi	r24, 0xF8	; 248
 7c4:	80 93 29 01 	sts	0x0129, r24
 7c8:	90 e0       	ldi	r25, 0x00	; 0
 7ca:	88 31       	cpi	r24, 0x18	; 24
 7cc:	09 f0       	breq	.+2      	; 0x7d0 <twi_set_write+0x32>
 7ce:	91 e0       	ldi	r25, 0x01	; 1
  if (TWI_S != MT_SLA_ACK)          // Check value of TWI Status Register. Mask prescaler bits.
    return 1;                                // If status different from ST_SLA_ACK go to ERROR
  else
    return 0;
}
 7d0:	89 2f       	mov	r24, r25
 7d2:	08 95       	ret

000007d4 <twi_write>:

char twi_write(char c)
{
  TWDR = c;                               // Load DATA into TWDR Register
 7d4:	80 93 bb 00 	sts	0x00BB, r24
  TWCR = (1<<TWINT) | (1<<TWEN);          // Clear TWINT bit in TWCR to start transmission of data
 7d8:	84 e8       	ldi	r24, 0x84	; 132
 7da:	80 93 bc 00 	sts	0x00BC, r24
  while (!(TWCR & (1<<TWINT)));           // Wait for TWINT flag set. This indicates that the DATA has been transmitted, and ACK/NACK has been received
 7de:	ec eb       	ldi	r30, 0xBC	; 188
 7e0:	f0 e0       	ldi	r31, 0x00	; 0
 7e2:	80 81       	ld	r24, Z
 7e4:	88 23       	and	r24, r24
 7e6:	ec f7       	brge	.-6      	; 0x7e2 <twi_write+0xe>
  TWI_S = (TWSR & 0xF8);
 7e8:	80 91 b9 00 	lds	r24, 0x00B9
 7ec:	88 7f       	andi	r24, 0xF8	; 248
 7ee:	80 93 29 01 	sts	0x0129, r24
 7f2:	90 e0       	ldi	r25, 0x00	; 0
 7f4:	88 32       	cpi	r24, 0x28	; 40
 7f6:	09 f0       	breq	.+2      	; 0x7fa <twi_write+0x26>
 7f8:	91 e0       	ldi	r25, 0x01	; 1
  if (TWI_S != MT_DATA_ACK)
    return 1;
  else
    return 0;
}
 7fa:	89 2f       	mov	r24, r25
 7fc:	08 95       	ret

000007fe <rtc_set_address>:
  //delay(20);
  return 0;
}

char rtc_set_address(char addr)
{
 7fe:	1f 93       	push	r17
 800:	18 2f       	mov	r17, r24
  if(twi_set_write() != 0)
 802:	cd df       	rcall	.-102    	; 0x79e <twi_set_write>
 804:	88 23       	and	r24, r24
 806:	11 f0       	breq	.+4      	; 0x80c <rtc_set_address+0xe>
 808:	81 e0       	ldi	r24, 0x01	; 1
 80a:	03 c0       	rjmp	.+6      	; 0x812 <rtc_set_address+0x14>
    return 1;
  twi_write(addr);
 80c:	81 2f       	mov	r24, r17
 80e:	e2 df       	rcall	.-60     	; 0x7d4 <twi_write>
 810:	80 e0       	ldi	r24, 0x00	; 0
  return 0;
}
 812:	1f 91       	pop	r17
 814:	08 95       	ret

00000816 <rtc_read>:
      return TWDR;
  }
}

clock_buffer rtc_read()
{
 816:	bf 92       	push	r11
 818:	cf 92       	push	r12
 81a:	df 92       	push	r13
 81c:	ef 92       	push	r14
 81e:	ff 92       	push	r15
 820:	0f 93       	push	r16
 822:	1f 93       	push	r17
 824:	df 93       	push	r29
 826:	cf 93       	push	r28
 828:	cd b7       	in	r28, 0x3d	; 61
 82a:	de b7       	in	r29, 0x3e	; 62
 82c:	27 97       	sbiw	r28, 0x07	; 7
 82e:	0f b6       	in	r0, 0x3f	; 63
 830:	f8 94       	cli
 832:	de bf       	out	0x3e, r29	; 62
 834:	0f be       	out	0x3f, r0	; 63
 836:	cd bf       	out	0x3d, r28	; 61
  clock_buffer buf = {0};
 
  rtc_set_address(0x00);
 838:	80 e0       	ldi	r24, 0x00	; 0
 83a:	e1 df       	rcall	.-62     	; 0x7fe <rtc_set_address>
  
  if(twi_set_read() != 0)
 83c:	66 df       	rcall	.-308    	; 0x70a <twi_set_read>
 83e:	88 23       	and	r24, r24
 840:	41 f0       	breq	.+16     	; 0x852 <rtc_read+0x3c>
 842:	bb 24       	eor	r11, r11
 844:	cc 24       	eor	r12, r12
 846:	dd 24       	eor	r13, r13
 848:	ee 24       	eor	r14, r14
 84a:	ff 24       	eor	r15, r15
 84c:	00 e0       	ldi	r16, 0x00	; 0
 84e:	10 e0       	ldi	r17, 0x00	; 0
 850:	16 c0       	rjmp	.+44     	; 0x87e <rtc_read+0x68>
    return buf;
  
  buf.seconds = twi_read(1);
 852:	81 e0       	ldi	r24, 0x01	; 1
 854:	75 df       	rcall	.-278    	; 0x740 <twi_read>
 856:	b8 2e       	mov	r11, r24
  buf.minutes = twi_read(1);
 858:	81 e0       	ldi	r24, 0x01	; 1
 85a:	72 df       	rcall	.-284    	; 0x740 <twi_read>
 85c:	c8 2e       	mov	r12, r24
  buf.hours = twi_read(1);
 85e:	81 e0       	ldi	r24, 0x01	; 1
 860:	6f df       	rcall	.-290    	; 0x740 <twi_read>
 862:	d8 2e       	mov	r13, r24
  buf.day = twi_read(1);
 864:	81 e0       	ldi	r24, 0x01	; 1
 866:	6c df       	rcall	.-296    	; 0x740 <twi_read>
 868:	e8 2e       	mov	r14, r24
  buf.date = twi_read(1);
 86a:	81 e0       	ldi	r24, 0x01	; 1
 86c:	69 df       	rcall	.-302    	; 0x740 <twi_read>
 86e:	f8 2e       	mov	r15, r24
  buf.month = twi_read(1);
 870:	81 e0       	ldi	r24, 0x01	; 1
 872:	66 df       	rcall	.-308    	; 0x740 <twi_read>
 874:	08 2f       	mov	r16, r24
  buf.year = twi_read(0);
 876:	80 e0       	ldi	r24, 0x00	; 0
 878:	63 df       	rcall	.-314    	; 0x740 <twi_read>
 87a:	18 2f       	mov	r17, r24
  
  twi_stop();
 87c:	41 df       	rcall	.-382    	; 0x700 <twi_stop>
  return buf;
}
 87e:	2b 2d       	mov	r18, r11
 880:	3c 2d       	mov	r19, r12
 882:	4d 2d       	mov	r20, r13
 884:	5e 2d       	mov	r21, r14
 886:	6f 2d       	mov	r22, r15
 888:	70 2f       	mov	r23, r16
 88a:	81 2f       	mov	r24, r17
 88c:	90 e0       	ldi	r25, 0x00	; 0
 88e:	27 96       	adiw	r28, 0x07	; 7
 890:	0f b6       	in	r0, 0x3f	; 63
 892:	f8 94       	cli
 894:	de bf       	out	0x3e, r29	; 62
 896:	0f be       	out	0x3f, r0	; 63
 898:	cd bf       	out	0x3d, r28	; 61
 89a:	cf 91       	pop	r28
 89c:	df 91       	pop	r29
 89e:	1f 91       	pop	r17
 8a0:	0f 91       	pop	r16
 8a2:	ff 90       	pop	r15
 8a4:	ef 90       	pop	r14
 8a6:	df 90       	pop	r13
 8a8:	cf 90       	pop	r12
 8aa:	bf 90       	pop	r11
 8ac:	08 95       	ret

000008ae <rtc_write>:
  else
    return 0;
}

char rtc_write(clock_buffer buf)
{
 8ae:	bf 92       	push	r11
 8b0:	cf 92       	push	r12
 8b2:	df 92       	push	r13
 8b4:	ef 92       	push	r14
 8b6:	ff 92       	push	r15
 8b8:	0f 93       	push	r16
 8ba:	1f 93       	push	r17
 8bc:	df 93       	push	r29
 8be:	cf 93       	push	r28
 8c0:	cd b7       	in	r28, 0x3d	; 61
 8c2:	de b7       	in	r29, 0x3e	; 62
 8c4:	27 97       	sbiw	r28, 0x07	; 7
 8c6:	0f b6       	in	r0, 0x3f	; 63
 8c8:	f8 94       	cli
 8ca:	de bf       	out	0x3e, r29	; 62
 8cc:	0f be       	out	0x3f, r0	; 63
 8ce:	cd bf       	out	0x3d, r28	; 61
 8d0:	a2 2f       	mov	r26, r18
 8d2:	29 83       	std	Y+1, r18	; 0x01
 8d4:	f3 2f       	mov	r31, r19
 8d6:	3a 83       	std	Y+2, r19	; 0x02
 8d8:	4b 83       	std	Y+3, r20	; 0x03
 8da:	5c 83       	std	Y+4, r21	; 0x04
 8dc:	6d 83       	std	Y+5, r22	; 0x05
 8de:	7e 83       	std	Y+6, r23	; 0x06
 8e0:	8f 83       	std	Y+7, r24	; 0x07
 8e2:	1a 2f       	mov	r17, r26
 8e4:	0f 2f       	mov	r16, r31
 8e6:	f4 2e       	mov	r15, r20
 8e8:	e5 2e       	mov	r14, r21
 8ea:	d6 2e       	mov	r13, r22
 8ec:	c7 2e       	mov	r12, r23
 8ee:	b8 2e       	mov	r11, r24
  if(twi_set_write() != 0)
 8f0:	56 df       	rcall	.-340    	; 0x79e <twi_set_write>
 8f2:	88 23       	and	r24, r24
 8f4:	11 f0       	breq	.+4      	; 0x8fa <rtc_write+0x4c>
 8f6:	88 e0       	ldi	r24, 0x08	; 8
 8f8:	2e c0       	rjmp	.+92     	; 0x956 <rtc_write+0xa8>
    return 8;
  twi_write(0x00);                       // Base address for writing time data
 8fa:	80 e0       	ldi	r24, 0x00	; 0
 8fc:	6b df       	rcall	.-298    	; 0x7d4 <twi_write>
  
  if(twi_write(buf.seconds)!=0)
 8fe:	81 2f       	mov	r24, r17
 900:	69 df       	rcall	.-302    	; 0x7d4 <twi_write>
 902:	88 23       	and	r24, r24
 904:	11 f0       	breq	.+4      	; 0x90a <rtc_write+0x5c>
 906:	87 e0       	ldi	r24, 0x07	; 7
 908:	26 c0       	rjmp	.+76     	; 0x956 <rtc_write+0xa8>
    return 7;
  if(twi_write(buf.minutes)!=0)
 90a:	80 2f       	mov	r24, r16
 90c:	63 df       	rcall	.-314    	; 0x7d4 <twi_write>
 90e:	88 23       	and	r24, r24
 910:	11 f0       	breq	.+4      	; 0x916 <rtc_write+0x68>
 912:	86 e0       	ldi	r24, 0x06	; 6
 914:	20 c0       	rjmp	.+64     	; 0x956 <rtc_write+0xa8>
    return 6;
  if(twi_write(buf.hours)!=0)
 916:	8f 2d       	mov	r24, r15
 918:	5d df       	rcall	.-326    	; 0x7d4 <twi_write>
 91a:	88 23       	and	r24, r24
 91c:	11 f0       	breq	.+4      	; 0x922 <rtc_write+0x74>
 91e:	85 e0       	ldi	r24, 0x05	; 5
 920:	1a c0       	rjmp	.+52     	; 0x956 <rtc_write+0xa8>
    return 5;
  if(twi_write(buf.day)!=0)
 922:	8e 2d       	mov	r24, r14
 924:	57 df       	rcall	.-338    	; 0x7d4 <twi_write>
 926:	88 23       	and	r24, r24
 928:	11 f0       	breq	.+4      	; 0x92e <rtc_write+0x80>
 92a:	84 e0       	ldi	r24, 0x04	; 4
 92c:	14 c0       	rjmp	.+40     	; 0x956 <rtc_write+0xa8>
    return 4;
  if(twi_write(buf.date)!=0)
 92e:	8d 2d       	mov	r24, r13
 930:	51 df       	rcall	.-350    	; 0x7d4 <twi_write>
 932:	88 23       	and	r24, r24
 934:	11 f0       	breq	.+4      	; 0x93a <rtc_write+0x8c>
 936:	83 e0       	ldi	r24, 0x03	; 3
 938:	0e c0       	rjmp	.+28     	; 0x956 <rtc_write+0xa8>
    return 3;
  if(twi_write(buf.month)!=0)
 93a:	8c 2d       	mov	r24, r12
 93c:	4b df       	rcall	.-362    	; 0x7d4 <twi_write>
 93e:	88 23       	and	r24, r24
 940:	11 f0       	breq	.+4      	; 0x946 <rtc_write+0x98>
 942:	82 e0       	ldi	r24, 0x02	; 2
 944:	08 c0       	rjmp	.+16     	; 0x956 <rtc_write+0xa8>
    return 2;
  if(twi_write(buf.year)!=0)
 946:	8b 2d       	mov	r24, r11
 948:	45 df       	rcall	.-374    	; 0x7d4 <twi_write>
 94a:	88 23       	and	r24, r24
 94c:	11 f0       	breq	.+4      	; 0x952 <rtc_write+0xa4>
 94e:	81 e0       	ldi	r24, 0x01	; 1
 950:	02 c0       	rjmp	.+4      	; 0x956 <rtc_write+0xa8>
    return 1;
  
  twi_stop();
 952:	d6 de       	rcall	.-596    	; 0x700 <twi_stop>
 954:	80 e0       	ldi	r24, 0x00	; 0
  return 0;
}
 956:	27 96       	adiw	r28, 0x07	; 7
 958:	0f b6       	in	r0, 0x3f	; 63
 95a:	f8 94       	cli
 95c:	de bf       	out	0x3e, r29	; 62
 95e:	0f be       	out	0x3f, r0	; 63
 960:	cd bf       	out	0x3d, r28	; 61
 962:	cf 91       	pop	r28
 964:	df 91       	pop	r29
 966:	1f 91       	pop	r17
 968:	0f 91       	pop	r16
 96a:	ff 90       	pop	r15
 96c:	ef 90       	pop	r14
 96e:	df 90       	pop	r13
 970:	cf 90       	pop	r12
 972:	bf 90       	pop	r11
 974:	08 95       	ret

00000976 <twi_read_byte>:


int twi_read_byte(char addr)
{
 976:	cf 93       	push	r28
 978:	df 93       	push	r29
  int data = 0;
  rtc_set_address(addr);
 97a:	41 df       	rcall	.-382    	; 0x7fe <rtc_set_address>
  
  if(twi_set_read() != 0)
 97c:	c6 de       	rcall	.-628    	; 0x70a <twi_set_read>
 97e:	88 23       	and	r24, r24
 980:	19 f0       	breq	.+6      	; 0x988 <twi_read_byte+0x12>
 982:	c0 e0       	ldi	r28, 0x00	; 0
 984:	d1 e0       	ldi	r29, 0x01	; 1
 986:	04 c0       	rjmp	.+8      	; 0x990 <twi_read_byte+0x1a>
    return ((1<<8) | 0x00);

  data = twi_read(0);
 988:	80 e0       	ldi	r24, 0x00	; 0
 98a:	da de       	rcall	.-588    	; 0x740 <twi_read>
 98c:	ec 01       	movw	r28, r24
  twi_stop();
 98e:	b8 de       	rcall	.-656    	; 0x700 <twi_stop>
  
  return data;  
}
 990:	8c 2f       	mov	r24, r28
 992:	9d 2f       	mov	r25, r29
 994:	df 91       	pop	r29
 996:	cf 91       	pop	r28
 998:	08 95       	ret

0000099a <twi_write_byte>:

char twi_write_byte(char addr, char data)
{
 99a:	0f 93       	push	r16
 99c:	1f 93       	push	r17
 99e:	18 2f       	mov	r17, r24
 9a0:	06 2f       	mov	r16, r22
  if(twi_set_write() != 0)
 9a2:	fd de       	rcall	.-518    	; 0x79e <twi_set_write>
 9a4:	88 23       	and	r24, r24
 9a6:	11 f0       	breq	.+4      	; 0x9ac <twi_write_byte+0x12>
 9a8:	82 e0       	ldi	r24, 0x02	; 2
 9aa:	0a c0       	rjmp	.+20     	; 0x9c0 <twi_write_byte+0x26>
    return 2;
  
  twi_write(addr);                       // Base address for writing time data
 9ac:	81 2f       	mov	r24, r17
 9ae:	12 df       	rcall	.-476    	; 0x7d4 <twi_write>
  
  if(twi_write(data)!=0)
 9b0:	80 2f       	mov	r24, r16
 9b2:	10 df       	rcall	.-480    	; 0x7d4 <twi_write>
 9b4:	88 23       	and	r24, r24
 9b6:	11 f0       	breq	.+4      	; 0x9bc <twi_write_byte+0x22>
 9b8:	81 e0       	ldi	r24, 0x01	; 1
 9ba:	02 c0       	rjmp	.+4      	; 0x9c0 <twi_write_byte+0x26>
    return 1;

  twi_stop();
 9bc:	a1 de       	rcall	.-702    	; 0x700 <twi_stop>
 9be:	80 e0       	ldi	r24, 0x00	; 0
  return 0;
}
 9c0:	1f 91       	pop	r17
 9c2:	0f 91       	pop	r16
 9c4:	08 95       	ret

000009c6 <to_bcd>:

char to_bcd(char nr)
{
 9c6:	48 2f       	mov	r20, r24
 9c8:	6a e0       	ldi	r22, 0x0A	; 10
 9ca:	2f d0       	rcall	.+94     	; 0xa2a <__udivmodqi4>
 9cc:	28 2f       	mov	r18, r24
 9ce:	30 e0       	ldi	r19, 0x00	; 0
 9d0:	22 95       	swap	r18
 9d2:	32 95       	swap	r19
 9d4:	30 7f       	andi	r19, 0xF0	; 240
 9d6:	32 27       	eor	r19, r18
 9d8:	20 7f       	andi	r18, 0xF0	; 240
 9da:	32 27       	eor	r19, r18
 9dc:	84 2f       	mov	r24, r20
 9de:	25 d0       	rcall	.+74     	; 0xa2a <__udivmodqi4>
  return ( ((nr/10)<<4) | (nr%10) );
}
 9e0:	89 2f       	mov	r24, r25
 9e2:	82 2b       	or	r24, r18
 9e4:	08 95       	ret

000009e6 <from_bcd>:

char from_bcd(char nr)
{
 9e6:	28 2f       	mov	r18, r24
 9e8:	22 95       	swap	r18
 9ea:	2f 70       	andi	r18, 0x0F	; 15
 9ec:	9a e0       	ldi	r25, 0x0A	; 10
 9ee:	29 9f       	mul	r18, r25
 9f0:	90 01       	movw	r18, r0
 9f2:	11 24       	eor	r1, r1
 9f4:	8f 70       	andi	r24, 0x0F	; 15
  return ( ((nr>>4)*10) + (nr & 0x0F) );
}
 9f6:	82 0f       	add	r24, r18
 9f8:	08 95       	ret

000009fa <bcd_inc>:

char bcd_inc(char nr)
{
  nr++;
 9fa:	98 2f       	mov	r25, r24
 9fc:	9f 5f       	subi	r25, 0xFF	; 255
  if((nr & 0x0F) == 0x0A)
 9fe:	89 2f       	mov	r24, r25
 a00:	8f 70       	andi	r24, 0x0F	; 15
 a02:	8a 30       	cpi	r24, 0x0A	; 10
 a04:	09 f4       	brne	.+2      	; 0xa08 <bcd_inc+0xe>
    nr += 6;
 a06:	9a 5f       	subi	r25, 0xFA	; 250
  if(nr > 99)
 a08:	94 36       	cpi	r25, 0x64	; 100
 a0a:	08 f0       	brcs	.+2      	; 0xa0e <bcd_inc+0x14>
 a0c:	90 e0       	ldi	r25, 0x00	; 0
    nr = 0;
  return nr;
}
 a0e:	89 2f       	mov	r24, r25
 a10:	08 95       	ret

00000a12 <bcd_dec>:

char bcd_dec(char nr)
{
  nr--;
 a12:	98 2f       	mov	r25, r24
 a14:	91 50       	subi	r25, 0x01	; 1
  if((nr & 0x0F) == 0x0F)
 a16:	89 2f       	mov	r24, r25
 a18:	8f 70       	andi	r24, 0x0F	; 15
 a1a:	8f 30       	cpi	r24, 0x0F	; 15
 a1c:	09 f4       	brne	.+2      	; 0xa20 <bcd_dec+0xe>
    nr -= 6;
 a1e:	96 50       	subi	r25, 0x06	; 6
  if(nr > 99)
 a20:	94 36       	cpi	r25, 0x64	; 100
 a22:	08 f0       	brcs	.+2      	; 0xa26 <bcd_dec+0x14>
 a24:	90 e0       	ldi	r25, 0x00	; 0
    nr = 0;
  return nr;
}
 a26:	89 2f       	mov	r24, r25
 a28:	08 95       	ret

00000a2a <__udivmodqi4>:
 a2a:	99 1b       	sub	r25, r25
 a2c:	79 e0       	ldi	r23, 0x09	; 9
 a2e:	04 c0       	rjmp	.+8      	; 0xa38 <__udivmodqi4_ep>

00000a30 <__udivmodqi4_loop>:
 a30:	99 1f       	adc	r25, r25
 a32:	96 17       	cp	r25, r22
 a34:	08 f0       	brcs	.+2      	; 0xa38 <__udivmodqi4_ep>
 a36:	96 1b       	sub	r25, r22

00000a38 <__udivmodqi4_ep>:
 a38:	88 1f       	adc	r24, r24
 a3a:	7a 95       	dec	r23
 a3c:	c9 f7       	brne	.-14     	; 0xa30 <__udivmodqi4_loop>
 a3e:	80 95       	com	r24
 a40:	08 95       	ret

00000a42 <_exit>:
 a42:	f8 94       	cli

00000a44 <__stop_program>:
 a44:	ff cf       	rjmp	.-2      	; 0xa44 <__stop_program>
